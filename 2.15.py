# Реализуйте декоратор @recviz, который полностью визуализирует выполнение декорируемой функции, в том числе и рекурсивной.
# Декоратор должен отображать все рекурсивные вызовы и возвращаемые значения, полученные при этих вызовах, причем рекурсивные вызовы, выполняемые в глубину, должны отделяться друг от друга четырьмя пробелами.
# Очередной вызов декорируемой функции при визуализации должен включать в себя знак ->, имя декорируемой функции и аргументы, переданные при этом вызове.
# Возвращаемое значение при визуализации должно включать в себя знак <- и непосредственно само возвращаемое значение.
# Примечание 1. Рекурсивный вызов и возвращаемое значение, полученное при этом вызове, должны находиться на одном уровне отступов.
# Примечание 2. Не забывайте, что декоратор не должен поглощать возвращаемое значение декорируемой функции, а также должен уметь декорировать функции с произвольным количеством позиционных и именованных аргументов.
# Примечание 3. В тестирующую систему сдайте программу, содержащую только необходимый декоратор @recviz, но не код, вызывающий его.

import functools

def recviz(func):
    count = -1
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        nonlocal count
        count += 1
        args_repr = list(map(repr, args))
        kwargs_repr = [f'{k}={repr(v)}' for k, v in kwargs.items()]
        print(f'{'    ' * count}-> {func.__name__}({', '.join(args_repr + kwargs_repr)})')
        values = func(*args, **kwargs)
        print(f'{'    ' * count}<- {repr(values)}')
        count -= 1
        return values
    return wrapper



