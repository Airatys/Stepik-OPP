# 1. Реализуйте класс Summator, описывающий объект, вычисляющий сумму натуральных чисел от 1 до n:
# 1+2+3+...+n
# 1+2+3+...+n При создании экземпляра класс не должен принимать никаких аргументов.
# Класс Summator должен иметь один метод экземпляра:
#     total() — метод, принимающий в качестве аргумента целое число n и возвращающий сумму целых чисел от 1 до n включительно
# 2. Помимо этого, реализуйте класс SquareSummator, наследника класса Summator, описывающий объект, вычисляющий сумму квадратов натуральных чисел от 1 до n:
# 1**2+2**2+3**2+...+n**2
# 1**2+2**2+3**2+...+n**2 Процесс создания экземпляра класса SquareSummator должен совпадать с процессом создания экземпляра класса Summator.
# Класс SquareSummator должен иметь один метод экземпляра:
#     total() — метод, принимающий в качестве аргумента целое число n и возвращающий сумму квадратов целых чисел от 1 до n включительно
# 3. Также реализуйте класс QubeSummator, наследника класса Summator, описывающий объект, вычисляющий сумму кубов натуральных чисел от 1 до n:
# 1**3+2**3+3**3+...+n**3
# 1**3+23+3**3+...+n**3
# Процесс создания экземпляра класса QubeSummator должен совпадать с процессом создания экземпляра класса Summator.
# Класс QubeSummator должен иметь один метод экземпляра:
#     total() — метод, принимающий в качестве аргумента целое число n и возвращающий сумму кубов целых чисел от 1 до n включительно
# 4. Наконец, реализуйте класс CustomSummator, наследника класса Summator, описывающий объект, вычисляющий сумму произвольных степеней натуральных чисел от 1 до n:
# 1**m+2**m+3**m+...+n**m
# 1**m+2**m+3**m+...+n**m
# При создании экземпляра класс должен принимать один аргумент:
#     m — степень чисел в последовательности
# Класс CustomSummator должен иметь один метод экземпляра:
#     total() — метод, принимающий в качестве аргумента целое число n и возвращающий сумму целых чисел в степени m от 1 до n включительно
# Примечание 1. Попытайтесь реализовать классы таким образом, чтобы метод total() был определен лишь в классе Summator.
# Примечание 2. Дополнительная проверка данных на корректность не требуется. Гарантируется, что реализованный класс используется только с корректными данными.
# Примечание 3. Никаких ограничений касательно реализации классов нет, она может быть произвольной.

class Summator:
    m = 1
    def total(self, n):
        return sum([i**self.m for i in range(n+1)])

class SquareSummator(Summator):
    m = 2

class QubeSummator(Summator):
    m = 3

class CustomSummator(Summator):
    def __init__(self, m):
        self.m = m



